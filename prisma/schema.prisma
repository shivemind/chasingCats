// Prisma schema for Chasing Cats Club platform

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  // If Vercel gives you POSTGRES_URL_NON_POOLING later, you can add:
  // directUrl = env("POSTGRES_URL_NON_POOLING")
}

model User {
  id                String             @id @default(cuid())
  name              String?
  email             String?            @unique
  emailVerified     DateTime?
  image             String?
  hashedPassword    String?
  role              UserRole           @default(MEMBER)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  accounts          Account[]
  sessions          Session[]
  profile           Profile?
  memberships       Membership[]
  comments          Comment[]
  questions         Question[]
  watchStatuses     WatchStatus[]
  uploads           MediaUpload[]
  announcements    Announcement[]
}

enum UserRole {
  MEMBER
  ADMIN
}

model Profile {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id])
  username      String   @unique
  bio           String?
  location      String?
  favoriteCat   String?
  quizResult    String?
  photoUrl      String?
  instagram     String?
  website       String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Account {
  id                 String   @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?
  oauth_token_secret String?
  oauth_token        String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Membership {
  id                 String            @id @default(cuid())
  userId             String
  stripeCustomerId   String?           @unique
  stripeSubscription String?
  plan               SubscriptionPlan  @default(MONTHLY)
  status             SubscriptionStatus @default(ACTIVE)
  currentPeriodEnd   DateTime?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  user               User              @relation(fields: [userId], references: [id])
}

enum SubscriptionPlan {
  MONTHLY
  ANNUAL
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  INCOMPLETE
  PAST_DUE
  TRIALING
}

model Category {
  id        String    @id @default(cuid())
  name      String
  slug      String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  contents  Content[]
}

model Content {
  id             String          @id @default(cuid())
  title          String
  slug           String          @unique
  excerpt        String
  body           String
  type           ContentType
  thumbnailUrl   String?
  videoUrl       String?
  resourceUrl    String?
  publishedAt    DateTime?
  duration       Int?
  featured       Boolean         @default(false)
  level          SkillLevel      @default(ALL_LEVELS)
  region         String?
  species        String?
  topic          String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  categoryId     String?
  category       Category?       @relation(fields: [categoryId], references: [id])
  comments       Comment[]
  watchStatuses  WatchStatus[]
  relatedContent RelatedContent[] @relation("RelatedContentSelf")
  relatedTo      RelatedContent[] @relation("RelatedContentOther")
  questions      Question[]
}

enum ContentType {
  ARTICLE
  VIDEO
  TALK
  COURSE
  NEWS
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  ALL_LEVELS
}

model RelatedContent {
  id        String  @id @default(cuid())
  contentId String
  relatedId String
  order     Int     @default(0)
  content   Content @relation("RelatedContentSelf", fields: [contentId], references: [id])
  related   Content @relation("RelatedContentOther", fields: [relatedId], references: [id])

  @@unique([contentId, relatedId])
}

model Comment {
  id        String   @id @default(cuid())
  body      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  authorId  String
  contentId String?
  author    User     @relation(fields: [authorId], references: [id])
  content   Content? @relation(fields: [contentId], references: [id])
}

model Question {
  id          String     @id @default(cuid())
  question    String
  status      QuestionStatus @default(PENDING)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  authorId    String
  contentId   String?
  author      User       @relation(fields: [authorId], references: [id])
  content     Content?   @relation(fields: [contentId], references: [id])
}

enum QuestionStatus {
  PENDING
  ANSWERED
  ARCHIVED
}

model WatchStatus {
  id        String   @id @default(cuid())
  userId    String
  contentId String
  watched   Boolean  @default(false)
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])
  content   Content  @relation(fields: [contentId], references: [id])

  @@unique([userId, contentId])
}

model MediaUpload {
  id          String   @id @default(cuid())
  userId      String
  title       String
  description String?
  mediaUrl    String
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id])
}

model Event {
  id           String    @id @default(cuid())
  title        String
  slug         String    @unique
  description  String
  startTime    DateTime
  endTime      DateTime?
  location     String?
  zoomLink     String?
  host         String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

model Announcement {
  id          String   @id @default(cuid())
  title       String
  body        String
  publishedAt DateTime @default(now())
  authorId    String?
  author      User?    @relation(fields: [authorId], references: [id])
}
